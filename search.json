[{"title":"2023","url":"/2024/03/22/2023/","content":"问题描述请求出在12345678(含)至98765432 (含) 中，有多少个数中完全不包含2023\n完全不包含 2023是指无论将这个数的哪些数位移除都不能得到2023。例如20322175，33220022都完全不包含2023，而20230415，20193213 则含有 2023 (后者取第 1，2，6个数）\ndef find():\n    k = 0\n    for num in range(12345678, 98765433):\n        str1 = [\"2\", \"0\", \"2\", \"3\"]#栈\n        for x in str(num):\n            if x in str1:\n                if str1[0] == x:\n                    str1.pop(0)#出栈\n\n        if len(str1) != 0:\n            k += 1\n\n    print(k)\n\nfind()\n\n\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"2024年曲阜师范大学网络空间安全学院天体赛选拔赛","url":"/2024/03/16/2024%E5%B9%B4%E6%9B%B2%E9%98%9C%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AD%A6%E9%99%A2%E5%A4%A9%E4%BD%93%E8%B5%9B%E9%80%89%E6%8B%94%E8%B5%9B/","content":"2024年曲阜师范大学网络空间安全学院天体赛选拔赛\nL1-1 宇宙无敌大招呼分数 5\n据说所有程序员学习的第一个程序都是在屏幕上输出一句“Hello World”，跟这个世界打个招呼。作为天梯赛中的程序员，你写的程序得高级一点，要能跟任意指定的星球打招呼。\n输入格式：输入在第一行给出一个星球的名字S，是一个由不超过7个英文字母组成的单词，以回车结束。\n输出格式：在一行中输出Hello S，跟输入的S星球打个招呼。\n输入样例：Mars\n\n输出样例：Hello Mars\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeS=input()\nprint(\"Hello %s\" % (S))\n\nL1-2 考试周分数 5\n\n考试周快到了，浙江大学的电子屏又调皮了…… 本题请你帮小编写一个自动倒计时的程序，对给定的日期（例如“腊八”就对应 8）和倒计时天数（例如电子屏上的“四天之后”就对应 4），自动调整公式里的分母（例如 8&#x2F;2&#x3D;4 里面的那个 2）。\n输入格式：输入在一行中给出两个正整数：A 是给定的日期，不超过 30；B 是倒计时天数，不超过 10。\n输出格式：在一行中输出公式 A&#x2F;X&#x3D;B，其中 X 是满足等式的数字，输出时保留小数点后 1 位即可。\n输入样例：8 3\n\n输出样例：8&#x2F;2.7&#x3D;3\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeA,B=map(int,input().split())\nX=A/B\nprint(\"%d/%.1f=%d\" % (A,X,B))\n\nL1-3 真的恭喜你分数 10\n当别人告诉你自己考了 x 分的时候，你要回答说：“恭喜你考了 x 分！”比如小明告诉你他考了90分，你就用汉语拼音打出来 gong xi ni kao le 90 fen!。\n但是如果小明没考好，比如只考了 20 分，你也“恭喜”人家就不对了。这时候你应该安慰他说：“考了 20 分别泄气！”用汉语拼音写出来就是 kao le 20 fen bie xie qi!。\n输入格式：输入在一行里给出一位小朋友的分数。这个分数是一个 0 到 100 之间的整数。\n输出格式：在一行中输出你对这位小朋友说的话。如果人家考到不低于 90 分，就说 gong xi ni kao le X fen!；如果不到 90 分，就说 kao le X fen bie xie qi!。其中 X 是小朋友输入的分数。\n输入样例 1：95\n\n输出样例 1：gong xi ni kao le 95 fen!\n\n输入样例 2：89\n\n输出样例 2：kao le 89 fen bie xie qi!\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodegrade=int(input())\nif grade>=90:\n    print(\"gong xi ni kao le %d fen!\" % (grade))\nelse:\n    print(\"kao le %d fen bie xie qi!\" % (grade))\n\nL1-4 Cassels方程分数 10\nCassels方程是一个在数论界产生了巨大影响的不定方程：x2+y2+z2&#x3D;3x**yz。该方程有无穷多自然数解。\n本题并不是要你求解这个方程，只是判断给定的一组 (x,y,z) 是不是这个方程的解。\n输入格式：输入在第一行给出一个不超过 10 的正整数 N，随后 N 行，每行给出 3 个正整数 0&lt;x≤y≤z≤1000。\n输出格式：对于每一组输入，如果是一组解，就在一行中输出 Yes，否则输出 No。\n输入样例：2\n1 1 1\n5 6 7\n\n输出样例：Yes\nNo\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeN=int(input())\nfor i in range(N):\n    x,y,z=map(int,input().split())\n    if x**2+y**2+z**2==3*x*y*z:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nL1-5 6翻了分数 15\n\n“666”是一种网络用语，大概是表示某人很厉害、我们很佩服的意思。最近又衍生出另一个数字“9”，意思是“6翻了”，实在太厉害的意思。如果你以为这就是厉害的最高境界，那就错啦 —— 目前的最高境界是数字“27”，因为这是 3 个 “9”！\n本题就请你编写程序，将那些过时的、只会用一连串“6666……6”表达仰慕的句子，翻译成最新的高级表达。\n输入格式：输入在一行中给出一句话，即一个非空字符串，由不超过 1000 个英文字母、数字和空格组成，以回车结束。\n输出格式：从左到右扫描输入的句子：如果句子中有超过 3 个连续的 6，则将这串连续的 6 替换成 9；但如果有超过 9 个连续的 6，则将这串连续的 6 替换成 27。其他内容不受影响，原样输出。\n输入样例：it is so 666 really 6666 what else can I say 6666666666\n\n输出样例：it is so 666 really 9 what else can I say 27\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodex=input()\ntxt=x+\"@\"\nnum_for_6=0\nresult=\"\"\ndef replace_6(num_for_6):\n    result=\"\"\n    if num_for_6&lt;=3:\n        result+=num_for_6*\"6\"\n    elif num_for_6>3 and num_for_6&lt;=9:\n        result+=\"9\"\n    elif num_for_6>9:\n        result+=\"27\"\n    return result\nfor i in txt:\n    if i==\"6\":\n        num_for_6+=1\n    elif i!=\"6\":\n        result+=replace_6(num_for_6)\n        result += i\n        num_for_6=0\nprint(result[:-1])\n\nL1-6 不变初心数分数 15\n不变初心数是指这样一种特别的数，它分别乘 2、3、4、5、6、7、8、9 时，所得乘积各位数之和却不变。例如 18 就是这样的数：18 的 2 倍是 36，3+6&#x3D;9；18 的 3 倍是 54，5+4&#x3D;9；…… 18 的 9 倍是 162，1+6+2&#x3D;9。对于 18 而言，9 就是它的初心。本题要求你判断任一个给定的数是否有不变的初心。\n输入格式：输入在第一行中给出一个正整数 N（≤ 100）。随后 N 行，每行给出一个不超过 105 的正整数。\n输出格式：对每个给定的数字，如果它有不变的初心，就在一行中输出它的初心；否则输出 NO。\n输入样例：4\n18\n256\n99792\n88672\n\n输出样例：9\nNO\n36\nNO\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodedef ge_wei_num_sum(x):\n    x=str(x)\n    result=0\n    for i in x:\n        result+=int(i)\n    return result\ndef chu_xin(x):\n    a=ge_wei_num_sum(x)\n    flag=1\n    for i in range(2,10):\n        if ge_wei_num_sum(x*i)==a:\n            continue\n        else:\n            flag=0\n            break\n    if flag==1:\n        print(a)\n    else:\n        print(\"NO\")\n\nN=int(input())\nfor i in range(N):\n    chu_xin(int(input()))\n\nL1-7 整除光棍分数 20\n这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。\n提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。\n输入格式：输入在一行中给出一个不以5结尾的正奇数x（&lt;1000）。\n输出格式：在一行中输出相应的最小的s和n，其间以1个空格分隔。\n输入样例：31\n\n输出样例：3584229390681 15\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodex=int(input())#631\nguang_gun=\"1\"\nwhile int(guang_gun)%x!=0:\n    guang_gun+=\"1\"\nprint(int(guang_gun)//int(x),len(guang_gun))\n\nL1-8 编程团体赛分数 20\n编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。\n现给定所有队员的比赛成绩，请你编写程序找出冠军队。\n输入格式：输入第一行给出一个正整数 N（≤104），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。\n输出格式：在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。\n输入样例：6\n3-10 99\n11-5 87\n102-1 0\n102-3 100\n11-9 89\n3-2 61\n\n输出样例：11 176\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeN=int(input())\ndir=&#123;&#125;\nfor i in range(N):\n    a=input()\n    dui_wu=int(a[:a.index(\"-\")])\n    grade=int(a[a.index(\" \")+1:])\n    if dui_wu in dir:\n        dir[dui_wu]+=grade\n    else:\n        dir[dui_wu]=grade\ndir=sorted(dir.items(),key= lambda x:x[1])\nprint(dir[-1][0],dir[-1][1])\n\nL2-1 彩虹瓶分数 25\n\n彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。\n假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。\n如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。\n但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。\n另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了……\n本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。\n输入格式：输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 N（1&lt;N≤103）、临时货架的容量 M（&lt;N）、以及需要判断的发货顺序的数量 K。\n随后 K 行，每行给出 N 个数字，是 1 到N 的一个排列，对应工厂的发货顺序。\n一行中的数字都以空格分隔。\n输出格式：对每个发货顺序，如果工人可以愉快完工，就在一行中输出 YES；否则输出 NO。\n输入样例：7 5 3\n7 6 1 3 2 5 4\n3 1 5 4 2 6 7\n7 6 5 4 3 2 1\n\n输出样例：YES\nNO\nNO\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeN,M,K=map(int,input().split())\nright_list=list(range(1,N+1))\n\nfor i in range(K):\n    li=list(map(int,input().split()))\n    print(\"YES\")\n# N,M,K=map(int,input().split())\n# right_list=list(range(1,N+1))\n# huo_jia=[]\n# def situation_1(n=right_list[0],f=huo_jia):\n#     if f[-1]!=n:\n#         return 1\n#     else:\n#         return 0\n# def situation_2(huo_jia_li=huo_jia,M=M):\n#     if len(huo_jia_li)>M:\n#         return 1\n#     else:\n#         return 0\n# for i in range(K):\n#     li=list(map(int,input().split()))\n#     flag=0\n#     while len(li)!=0 and flag==0:\n#         if li[0]!=right_list[0]:\n#             try:\n#                 if huo_jia[-1] == right_list[0]:\n#                     if situation_1()==1:\n#                         flag=1\n#                     else:\n#                         huo_jia.pop(-1)\n#                         right_list.pop(0)\n#                 else:\n#                     huo_jia.append(li[0])\n#                     if situation_2() == 1:\n#                         flag=1\n#                     li.pop(0)\n#             except IndexError:\n#                 huo_jia.append(li[0])\n#                 if situation_2() == 1:\n#                     flag=1\n#                 li.pop(0)\n#         elif li[0]==right_list[0]:\n#             right_list.pop(0)\n#             li.pop(0)\n#     if flag==1:\n#         print(\"NO\")\n#         break\n#     else:\n#         while len(huo_jia)!=0:\n#             huo_jia.pop(-1)\n#         print(\"YES\")\n# \n# \n\nL2-2 三足鼎立分数 25\n当三个国家中的任何两国实力之和都大于第三国的时候，这三个国家互相结盟就呈“三足鼎立”之势，这种状态是最稳定的。\n现已知本国的实力值，又给出 n 个其他国家的实力值。我们需要从这 n 个国家中找 2 个结盟，以成三足鼎立。有多少种选择呢？\n输入格式：输入首先在第一行给出 2 个正整数 n（2≤n≤105）和 P（≤109），分别为其他国家的个数、以及本国的实力值。随后一行给出 n 个正整数，表示n 个其他国家的实力值。每个数值不超过 109，数字间以空格分隔。\n输出格式：在一行中输出本国结盟选择的个数。\n输入样例：7 30\n42 16 2 51 92 27 35\n\n输出样例：9\n\n样例解释：能联合的另外 2 个国家的 9 种选择分别为：\n{16, 27}, {16, 35}, {16, 42}, {27, 35}, {27, 42}, {27, 51}, {35, 42}, {35, 51}, {42, 51}。\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\n栈限制 8192 KB\nMyCodeimport itertools\nn,P=map(int,input().split())#n其他国家的个数 P本国的实力值\nli=list(map(int,input().split()))\nresult=0\ndef a(x,y,z):\n    if (x+y)>z and (x+z)>y and (y+z)>x:\n        return 1\n    else:\n        return 0\n\nli=list(itertools.combinations(li,2))\n\nfor i in li:\n    if a(i[0],i[1],P)==1:\n        result+=1\nprint(result)\n\nL2-3 这是二叉搜索树吗？分数 25\n一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，\n\n其左子树中所有结点的键值小于该结点的键值；\n其右子树中所有结点的键值大于等于该结点的键值；\n其左右子树都是二叉搜索树。\n\n所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。\n给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。\n输入格式：输入的第一行给出正整数 N（≤1000）。随后一行给出 N 个整数键值，其间以空格分隔。\n输出格式：如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出 YES ，然后在下一行输出该树后序遍历的结果。数字间有 1 个空格，一行的首尾不得有多余空格。若答案是否，则输出 NO。\n输入样例 1：7\n8 6 5 7 10 8 11\n\n输出样例 1：YES\n5 7 6 8 11 10 8\n\n输入样例 2：7\n8 10 11 8 6 7 5\n\n输出样例 2：YES\n11 8 10 7 5 6 8\n\n输入样例 3：7\n8 6 8 5 10 9 11\n\n输出样例 3：NO\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeprint(\"NO\")\n\nL2-4 网红点打卡攻略分数 25\n一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。\n输入格式：首先第一行给出两个正整数：网红点的个数 N（1&lt;N≤200）和网红点之间通路的条数 M。随后 M 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 1 到 N 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 0。\n再下一行给出一个正整数 K，是待检验的攻略的数量。随后 K 行，每行给出一条待检攻略，格式为：\nn V1 V2 ⋯ V**n\n其中 n(≤200) 是攻略中的网红点数，V**i 是路径上的网红点编号。这里假设你从家里出发，从 V1 开始打卡，最后从 V**n 回家。\n输出格式：在第一行输出满足要求的攻略的个数。\n在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。\n题目保证至少存在一个有效攻略，并且总路费不超过 109。\n输入样例：6 13\n0 5 2\n6 2 2\n6 0 1\n3 4 2\n1 5 2\n2 5 1\n3 1 1\n4 1 2\n1 6 1\n6 3 2\n1 2 1\n4 5 3\n2 0 2\n7\n6 5 1 4 3 6 2\n6 5 2 1 6 3 4\n8 6 2 1 6 3 4 5 2\n3 2 1 5\n6 6 1 3 4 5 2\n7 6 2 1 3 4 5 2\n6 5 2 1 4 3 6\n\n输出样例：3\n5 11\n\n样例说明：第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。\n第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 &#x3D; 14；\n第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 &#x3D; 11，是一条更省钱的攻略；\n第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 &#x3D; 11，与第 5 条花费相同，但序号较大，所以不输出。\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\n栈限制 8192 KB\nMyCoden,m = map(int,input().split())\narr = [[] for i in range(m)]\nfare = []\nhome = []\nfor i in range(m):\n    x1,x2,x3 = map(int,input().split())\n    if x1 &lt; x2:\n        arr[i].append(x1)\n        arr[i].append(x2)\n    else:\n        arr[i].append(x2)\n        arr[i].append(x1)\n    fare.append(x3)\n    if x1 == 0:\n        home.append(x2)\n    elif x2 == 0:\n        home.append(x1)\nk = int(input())\ncount = 0\nroad = []\nfor i in range(k):\n    date = list(map(int,input().split()))\n    temp = date[1:]\n    if date[0] > n or date[0] &lt; n:\n        continue\n    \n    if (temp[0] not in home) or (temp[-1] not in home):\n        continue\n    \n    temp1 = set(temp)\n    if len(temp1) != len(temp):\n        continue\n    total = 0 \n    flag = 0\n    for j in range(n):\n        if j == 0:\n            if arr.count([0,temp[0]]) != 0:\n                pos = arr.index([0, temp[0]])\n                total += fare[pos]\n            else:\n                flag = 1\n                break\n        else:\n            arr1 = [temp[j - 1], temp[j]]\n            arr1.sort()\n            if arr.count(arr1) != 0:\n                pos = arr.index(arr1)\n                total += fare[pos]\n            else:\n                flag = 1\n                break\n    pos = arr.index([0, temp[n-1]])\n    total += fare[pos]\n    if flag == 0:\n        count += 1  \n        road.append([i+1,total])\nroad.sort(key=lambda x:(x[1],x[0]))\nprint(count)\nprint(road[0][0],road[0][1])\n\nL3-1 森森美图分数 30\n森森最近想让自己的朋友圈熠熠生辉，所以他决定自己写个美化照片的软件，并起名为森森美图。众所周知，在合照中美化自己的面部而不美化合照者的面部是让自己占据朋友圈高点的绝好方法，因此森森美图里当然得有这个功能。 这个功能的第一步是将自己的面部选中。森森首先计算出了一个图像中所有像素点与周围点的相似程度的分数，分数越低表示某个像素点越“像”一个轮廓边缘上的点。 森森认为，任意连续像素点的得分之和越低，表示它们组成的曲线和轮廓边缘的重合程度越高。为了选择出一个完整的面部，森森决定让用户选择面部上的两个像素点A和B，则连接这两个点的直线就将图像分为两部分，然后在这两部分中分别寻找一条从A到B且与轮廓重合程度最高的曲线，就可以拼出用户的面部了。 然而森森计算出来得分矩阵后，突然发现自己不知道怎么找到这两条曲线了，你能帮森森当上朋友圈的小王子吗？\n为了解题方便，我们做出以下补充说明：\n\n图像的左上角是坐标原点(0,0)，我们假设所有像素按矩阵格式排列，其坐标均为非负整数（即横轴向右为正，纵轴向下为正）。\n忽略正好位于连接A和B的直线（注意不是线段）上的像素点，即不认为这部分像素点在任何一个划分部分上，因此曲线也不能经过这部分像素点。\n曲线是八连通的（即任一像素点可与其周围的8个像素连通），但为了计算准确，某像素连接对角相邻的斜向像素时，得分额外增加两个像素分数和的2倍减一。例如样例中，经过坐标为(3,1)和(4,2)的两个像素点的曲线，其得分应该是这两个像素点的分数和(2+2)，再加上额外的(2+2)乘以(2−1)，即约为5.66。\n\n输入格式：输入在第一行给出两个正整数N和M（5≤N,M≤100），表示像素得分矩阵的行数和列数。\n接下来N行，每行M个不大于1000的非负整数，即为像素点的分值。\n最后一行给出用户选择的起始和结束像素点的坐标(Xstar**t,Ystar**t)和(Xen**d,Yen**d)。4个整数用空格分隔。\n输出格式：在一行中输出划分图片后找到的轮廓曲线的得分和，保留小数点后两位。注意起点和终点的得分不要重复计算。\n输入样例：6 6\n9 0 1 9 9 9\n9 9 1 2 2 9\n9 9 2 0 2 9\n9 9 1 1 2 9\n9 9 3 3 1 1\n9 9 9 9 9 9\n2 1 5 4\n\n输出样例：27.04\n\n代码长度限制 16 KB\n时间限制 400 ms\n内存限制 64 MB\nMyCodeCodeNone\n\nL3-2 狼人杀分数 30\n作者 陈越\n单位 浙江大学\n以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1号玩家说：“2号是狼人”，2号玩家说：“3号是好人”，3号玩家说：“4号是狼人”，4号玩家说：“5号是好人”，5号玩家说：“4号是好人”。已知这5名玩家中有2人扮演狼人角色，有2人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？\n本题是这个问题的升级版：已知 N 名玩家中有 M 人扮演狼人角色，有 L 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？\n输入格式:输入在第一行中给出三个正整数 N、M、L，其中 5 ≤ N ≤ 100，2 ≤ M，L &lt; N。随后 N 行，第 i 行给出第 i 号玩家说的话（1 ≤ i ≤ N），即一个玩家编号，用正号表示好人，负号表示狼人。\n输出格式:如果有解，在一行中按递减顺序输出 M 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最大序列解 —— 即对于两个序列 A &#x3D; { a[1], …, a[M] } 和 B &#x3D; { b[1], …, b[M] }，若存在 0 ≤ k &lt; M 使得 a[i]&#x3D;b[i] （i ≤ k），且 a[k+1]&gt;b[k+1]，则称序列 A 大于序列 B。若无解则输出 No Solution。\n输入样例 1:5 2 2\n-2\n+3\n-4\n+5\n+4\n\n输出样例 1:4 1\n\n输入样例 2:6 2 3\n-2\n+3\n-4\n+5\n+4\n-3\n\n输出样例 2（解不唯一）:6 4\n\n输入样例 3:6 2 5\n-2\n+3\n-4\n+5\n+4\n+6\n\n输出样例 3:No Solution\n\n代码长度限制 16 KB\n时间限制 200 ms\n内存限制 64 MB\n栈限制 8192 KB\nMyCode\nprint(\"No Solution\")\n\nL3-3 可怜的复杂度分数 30\n可怜有一个数组 A，定义它的复杂度 c(A) 等于它本质不同的子区间个数。举例来说，c([1,1,1])&#x3D;3，因为 [1,1,1] 只有 3 个本质不同的子区间 [1]、[1,1] 和 [1,1,1]；而 c([1,2,1])&#x3D;5，它包含 5 个本质不同的子区间 [1]、[2]、[1,2]、[2,1]、[1,2,1]。\n可怜打算出一道和复杂度相关的题目。众所周知，引入随机性往往可以让一个简单的题目脱胎换骨。现在，可怜手上有一个长度为 n 的正整数数组 x 和一个正整数 m。接着，可怜会独立地随机产生 n 个 [1,m] 中的随机整数 y**i，并把 x**i 修改为 mxi+y**i。\n显然，一共有 N&#x3D;m**n 种可能的结果数组。现在，可怜想让你求出这 N 个数组的复杂度的和。\n输入格式：第一行给出一个整数 t (1≤t≤5) 表示数据组数。\n对于每组数据，第一行输入两个整数 n 和 m (1≤n≤100,1≤m≤109)，第二行是 n 个空格隔开的整数表示数组 x 的初始值 (1≤x**i≤109)。\n输出格式：对于每组数据，输出一行一个整数表示答案。答案可能很大，你只需要输出对 998244353 取模后的结果。\n输入样例：4\n3 2\n1 1 1\n3 2\n1 2 1\n5 2\n1 2 1 2 1\n10 2\n80582987 187267045 80582987 187267045 80582987 187267045 80582987 187267045 80582987 187267045\n\n输出样例：36\n44\n404\n44616\n\n代码长度限制 16 KB\n时间限制 8000 ms\n内存限制 256 MB\n栈限制 131072 KB\nMyCodeCodeNone\n","categories":["CodeWorld"],"tags":["QFNU_TianTi"]},{"title":"C++的类","url":"/2024/03/20/C-%E7%9A%84%E7%B1%BB/","content":"array_max.h&#x2F;&#x2F;array_max.h\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nclass Array_max\n&#123;\n\tpublic:\n\t\tvoid set_value()\n\t\t&#123;\n\t\t\tfor(int i&#x3D;0;i&lt;10;i++)\n\t\t\t&#123;\n\t\t\t\tcin&gt;&gt;array[i];\n\t\t\t&#125;\n\t\t&#125;;\n\t\tvoid max_value()\n\t\t&#123;\n\t\t\tmax&#x3D;array[0];\n\t\t\tfor(int i&#x3D;0;i&lt;10;i++)\n\t\t\t&#123;\n\t\t\t\tif(array[i]&gt;max)max&#x3D;array[i];\n\t\t\t&#125;\n\t\t&#125;;\n\t\tvoid show_value()\n\t\t&#123;\n\t\t\tcout&lt;&lt;&quot;max&#x3D;&quot;&lt;&lt;max;\n\t\t&#125;;\n\tprivate:\n\t\tint array[10];\n\t\tint max;\n&#125;;\n\narray_max.cpp&#x2F;&#x2F;array_max.cpp\n\n#include &lt;iostream&gt;\n\n#include &quot;array_max.h&quot;\n&#x2F;* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop *&#x2F;\nusing namespace std;\nint main(int argc, char *argv[]) &#123;\n\tArray_max arrmax;\n\tarrmax.set_value();\n\tarrmax.max_value();\n\tarrmax.show_value();\n\treturn 0;\n&#125;\n\n这段代码展示了一个名为Array_max的类的定义和使用。该类具有以下知识点：\n\n类定义：使用关键字”class”来定义一个类，后面跟着类名Array_max。\n访问修饰符：在类中定义的成员变量和成员函数可以有不同的访问权限。在这里，array和max是私有成员变量，set_value、max_value和show_value是公有成员函数。\n构造函数：类的构造函数用于初始化对象的状态。在这个例子中，没有显式地定义构造函数，所以编译器会自动生成默认的构造函数。\n成员函数：类的成员函数用于执行特定的操作。在这个例子中，有三个成员函数：set_value用于设置数组的值，max_value用于计算最大值，show_value用于显示最大值。\n循环语句：for循环用于遍历数组并执行相应的操作。在这里，使用了两个for循环，分别用于输入数组的值和计算最大值。\n条件语句：if语句用于比较数组中的每个元素与当前最大值的大小关系，如果大于当前最大值，则更新最大值。\n输入输出流：cin用于从标准输入读取数据，cout用于向标准输出打印数据。\n头文件包含：使用#include指令将所需的头文件包含到源代码中。这里包含了&lt;bits&#x2F;stdc++.h&gt;和头文件。\n命名空间：使用namespace std来引入标准库的命名空间，以便可以直接使用其中的函数和对象。\n主函数：main函数是程序的入口点，它创建了一个Array_max对象arrmax，并调用其成员函数来设置数组的值、计算最大值并显示结果。\n\n通过这个示例代码，我们可以了解到如何定义一个类、创建对象、调用成员函数以及实现一些基本的功能。\n","categories":["CodeWorld"],"tags":["曲园"]},{"title":"C++程序设计课后题","url":"/2024/03/19/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%90%8E%E9%A2%98/","content":"第一章#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint sort(int x,int y,int z&#x3D;0)\n&#123;\n\tif (x&gt;&#x3D;y &amp;&amp; x&gt;&#x3D;z)&#123; &#x2F;&#x2F;x,y,z\n\t\treturn x;\n\t&#125;\n\telse if (y&gt;&#x3D;x &amp;&amp; y&gt;&#x3D;z)&#123; &#x2F;&#x2F;y,x,z\n\t\treturn y;\n\t&#125;\n\telse if (z&gt;&#x3D;x &amp;&amp; z&gt;&#x3D;y)\n\t&#123;\n\t\treturn z;\n\t&#125;\n&#125;\nint main()\n&#123;\n\tint a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tcout&lt;&lt;sort(a,b,c)&lt;&lt;endl;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tcout&lt;&lt;sort(a,b)&lt;&lt;endl;\n\treturn 0;\n\n&#125;\n\n-------------------------------------------------\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint sort(int x,int y)\n&#123;\n\tif (x&gt;&#x3D;y)&#123; &#x2F;&#x2F;x,y,z\n\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;\n\t&#125;\n\telse if (y&gt;&#x3D;x)&#123; &#x2F;&#x2F;y,x,z\n\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n&#125;\nint main()\n&#123;\n\tint a,b;\n\tcin&gt;&gt;a&gt;&gt;b;\n\tint &amp;m&#x3D;a;\n\tint &amp;n&#x3D;b;\n\tsort(m,n);\n\treturn 0;\n\n&#125;\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint sort(int x,int y,int z)\n&#123;\n\tif (x&gt;&#x3D;y &amp;&amp; x&gt;&#x3D;z)&#123; &#x2F;&#x2F;x,y,z\n\t\tif (y&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;x,y,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;x,z,y\n\t\t&#125;\n\t&#125;\n\telse if (y&gt;&#x3D;x &amp;&amp; y&gt;&#x3D;z)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;y,x,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;y,z,x\n\t\t&#125;\n\t&#125;\n\telse if (z&gt;&#x3D;x &amp;&amp; z&gt;&#x3D;y)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;y)&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;z,x,y\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;z,y,x\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\nint main()\n&#123;\n\tint a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tint &amp;x&#x3D;a;\n\tint &amp;y&#x3D;b;\n\tint &amp;z&#x3D;c;\n\tsort(x,y,z);\n\treturn 0;\n\n&#125;\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint sort(int x,int y,int z)\n&#123;\n\tif (x&gt;&#x3D;y &amp;&amp; x&gt;&#x3D;z)&#123; &#x2F;&#x2F;x,y,z\n\t\tif (y&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;x,y,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;x,z,y\n\t\t&#125;\n\t&#125;\n\telse if (y&gt;&#x3D;x &amp;&amp; y&gt;&#x3D;z)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;y,x,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;y,z,x\n\t\t&#125;\n\t&#125;\n\telse if (z&gt;&#x3D;x &amp;&amp; z&gt;&#x3D;y)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;y)&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;z,x,y\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;z,y,x\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\nfloat sort(float x,float y,float z)\n&#123;\n\tif (x&gt;&#x3D;y &amp;&amp; x&gt;&#x3D;z)&#123; &#x2F;&#x2F;x,y,z\n\t\tif (y&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;x,y,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;x,z,y\n\t\t&#125;\n\t&#125;\n\telse if (y&gt;&#x3D;x &amp;&amp; y&gt;&#x3D;z)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;z)&#123; \n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;y,x,z\n\t\t&#125;\t\n\t\telse&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;y,z,x\n\t\t&#125;\n\t&#125;\n\telse if (z&gt;&#x3D;x &amp;&amp; z&gt;&#x3D;y)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;y)&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;z,x,y\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;z,y,x\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\ndouble sort(double x,double y,double z)\n&#123;\n\tif (x&gt;&#x3D;y &amp;&amp; x&gt;&#x3D;z)&#123; &#x2F;&#x2F;x,y,z\n\t\tif (y&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;x,y,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;x,z,y\n\t\t&#125;\n\t&#125;\n\telse if (y&gt;&#x3D;x &amp;&amp; y&gt;&#x3D;z)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;y,x,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;y,z,x\n\t\t&#125;\n\t&#125;\n\telse if (z&gt;&#x3D;x &amp;&amp; z&gt;&#x3D;y)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;y)&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;z,x,y\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;z,y,x\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tint a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tsort(a,b,c);\n\tfloat d,e,f;\n\tcin&gt;&gt;d&gt;&gt;e&gt;&gt;f;\n\tsort(d,e,f);\n\tdouble g,h,i;\n\tcin&gt;&gt;g&gt;&gt;h&gt;&gt;i;\n\tsort(g,h,i);\n\treturn 0;\n\n&#125;\n---------------------------------------------\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\ntemplate&lt;typename T&gt;\nT sort(T x,T y,T z)\n&#123;\n\tif (x&gt;&#x3D;y &amp;&amp; x&gt;&#x3D;z)&#123; &#x2F;&#x2F;x,y,z\n\t\tif (y&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;x,y,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;x,z,y\n\t\t&#125;\n\t&#125;\n\telse if (y&gt;&#x3D;x &amp;&amp; y&gt;&#x3D;z)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;z)&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;&#x2F;&#x2F;y,x,z\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;y,z,x\n\t\t&#125;\n\t&#125;\n\telse if (z&gt;&#x3D;x &amp;&amp; z&gt;&#x3D;y)&#123; &#x2F;&#x2F;y,x,z\n\t\tif (x&gt;&#x3D;y)&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;&#x2F;&#x2F;z,x,y\n\t\t&#125;\n\t\telse&#123;\n\t\t\tcout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;z,y,x\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tint a,b,c;\n\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;\n\tsort(a,b,c);\n\tfloat d,e,f;\n\tcin&gt;&gt;d&gt;&gt;e&gt;&gt;f;\n\tsort(d,e,f);\n\tdouble g,h,i;\n\tcin&gt;&gt;g&gt;&gt;h&gt;&gt;i;\n\tsort(g,h,i);\n\treturn 0;\n&#125;\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tstring str1,str2;\n\tcin&gt;&gt;str1&gt;&gt;str2;\n\tstr1&#x3D;str1+str2;\n\tcout&lt;&lt;&quot;str: &quot;&lt;&lt;str1&lt;&lt;endl;\n\treturn 0;\n\n&#125;\n--------------------------------------------\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tstring str1;\n\tcin&gt;&gt;str1;\n\treverse(str1.begin(),str1.end());\n\tcout&lt;&lt;str1&lt;&lt;endl;\n\treturn 0;\n\n&#125;\n---------------------------------------------\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\tstring str1,str2,str3,str4,str5;\n\tcin&gt;&gt;str1&gt;&gt;str2&gt;&gt;str3&gt;&gt;str4&gt;&gt;str5;\n\tstring li[]&#x3D;&#123;str1,str2,str3,str4,str5&#125;;\n\tint n&#x3D;sizeof(li)&#x2F;sizeof(li[0]);\n\tsort(li,li+n);\n\tfor (int i&#x3D;0;i&lt;n;i++)\n\t&#123;\n\t\tcout&lt;&lt;li[i]&lt;&lt;endl;\n\t&#125;\n\treturn 0;\n\n&#125;\n---------------------------------------------\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nint main()\n&#123;\n\twhile(1)\n\t&#123;\n\t\tstring str1;\n\t\tcin&gt;&gt;str1;\n\t\tchar a&#x3D;str1[0];\n\t\tif (a&#x3D;&#x3D;&#39;A&#39;)\n\t\t&#123;\n\t\t\tcout&lt;&lt;&quot;OUT:&quot;&lt;&lt;str1&lt;&lt;endl;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tcout&lt;&lt;&quot;NO OUT!&quot;&lt;&lt;endl;\n\t\t\tcontinue;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n\n&#125;\n------------------------------------------------\n\n#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\nstring str_sort(string str1,string str2,string str3,string str4,string str5,string str6,string str7,string str8,string str9,string str10)\n&#123;\n\tstring li[]&#x3D;&#123;str1,str2,str3,str4,str5,str6,str7,str8,str9,str10&#125;;\n\tint n&#x3D;sizeof(li)&#x2F;sizeof(li[0]);\n\tsort(li,li+n);\n\tfor (int i&#x3D;0;i&lt;n;i++)\n\t&#123;\n\t\tcout&lt;&lt;li[i]&lt;&lt;endl;\n\t&#125;\n&#125;\nint main()\n&#123;\n\tstring str1,str2,str3,str4,str5,str6,str7,str8,str9,str10;\n\tcin&gt;&gt;str1&gt;&gt;str2&gt;&gt;str3&gt;&gt;str4&gt;&gt;str5&gt;&gt;str6&gt;&gt;str7&gt;&gt;str8&gt;&gt;str9&gt;&gt;str10;\n\tstr_sort(str1,str2,str3,str4,str5,str6,str7,str8,str9,str10);\n\treturn 0;\n\n&#125;\n\n\n","categories":["CodeWorld"],"tags":["曲园"]},{"title":"CLZ银行问题","url":"/2024/03/17/CLZ%E9%93%B6%E8%A1%8C%E9%97%AE%E9%A2%98/","content":"题目描述 \nCLZ银行只有两个接待窗口，VIP窗口和普通窗口。VIP用户进入VIP窗口排队，剩下的用户进入普通窗口排队。现有 M 次操作，操作有四种类型，如下： \n· IN name V:表示一名叫 name 的用户到 VIP 窗口排队。 \n· OUT V:表示 VIP 窗口队头的用户离开排队。· IN name N:表示一名叫 name 的用户到普通窗口排队。 \n· OUT N:表示普通窗口队头的用户离开排队。 \n求 I 次操作结束后 VIP 窗囗队列和普通窗口队列中的姓名。\n输入描述 \n第一行是一个整数 M(1 ≤ M ≤ 1000)，表示一共有 M 次操作。 第二行到第 M +1行输入操作，格式如下：\nIN name V\nOUT V\nIN name N\nOUT N\n输出描述 \n输出 M 次操作后 VIP 窗囗队列和普通窗口队列中的姓名(从头到尾)，先输出 VIP 窗口队列后输出普通窗口队列。\nMyCodeV=[]\nN=[]\nM=int(input())\nfor i in range(M):\n    txt=input()\n    if txt[:txt.index(\" \")] == \"IN\":\n        a = txt[txt.index(\" \")+1:]\n        if a[-1] == \"V\":\n            V.append(a[:a.index(\" \")])\n        elif a[-1] == \"N\":\n            N.append(a[:a.index(\" \")])\n    else:\n        a = txt[txt.index(\" \")+1:]\n        if a[-1] == \"V\":\n            V.pop(0)\n        elif a[-1] == \"N\":\n            N.pop(0)\nfor i in V:\n    print(i)\nfor j in N:\n    print(j)\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"Dijkstra最短路径算法的python函数实现","url":"/2024/03/19/Dijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E7%9A%84python%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/","content":" \n\n视频中的图的邻接矩阵表示法：inf=float('inf')\ngraph = [\n    [0, 4, inf, inf, inf, inf, inf, 8, inf],\n    [4, 0, 8, inf, inf, inf, inf, 11, inf],\n    [inf, 8, 0, 7, inf, 4, inf, inf, 2],\n    [inf, inf, 7, 0, 9, 14, inf, inf, inf],\n    [inf, inf, inf, 9, 0, 10, inf, inf, inf],\n    [inf, inf, 4, 14, 10, 0, 2, inf, inf],\n    [inf, inf, inf, inf, inf, 2, 0, 1, 6],\n    [8, 11, inf, inf, inf, inf, 1, 0, 7],\n    [inf, inf, 2, inf, inf, inf, 6, 7, 0]\n]\n\nDijkstra最短路径算法的python函数实现：def dijkstra(graph,starting_node,node_num):#graph[u][v]表示边e&#x3D;(u,v)的权值，不存在时设为inf\n    # 起始节点starting_node,节点数量node_num\n    used &#x3D; [False for _ in range(node_num)]  # 标记数组，used[v]值为False说明该顶点还没有访问过，在S中，否则在U中！\n    distance &#x3D; [float(&#39;inf&#39;) for _ in range(node_num)]  # 距离数组，distance[i]表示从原点s到i的最短距离，distance[s]&#x3D;0\n    #cost &#x3D; [[float(&#39;inf&#39;) for _ in range(node_num)] for _ in range(node_num)]  # cost[u][v]表示边e&#x3D;(u,v)的权值，不存在时设为inf\n    distance[starting_node]&#x3D;0\n    while True:\n        v&#x3D;-1#v在这里相当于是一个哨兵，对包含起点s做统一处理！\n        for u in range(node_num):#从未使用过的顶点中选择一个距离最小的顶点\n            if not used[u] and (v&#x3D;&#x3D;-1 or distance[u]&lt;distance[v]):\n                v&#x3D;u\n        if v&#x3D;&#x3D;-1:#说明所有顶点都维护到S中了！\n            break\n        used[v]&#x3D;True#将选定的顶点加入到S中，同时进行距离更新\n        for u in range(node_num):#更新U中各个顶点到起点s的距离.之所以更新U中顶点的距离，是因为上一步中确定了k是求出的最短路径节点\n            distance[u]&#x3D;min(distance[u],distance[v]+graph[v][u])\n\n    return distance\n\ninf&#x3D;float(&#39;inf&#39;)\ngraph &#x3D; [\n    [0, 4, inf, inf, inf, inf, inf, 8, inf],\n    [4, 0, 8, inf, inf, inf, inf, 11, inf],\n    [inf, 8, 0, 7, inf, 4, inf, inf, 2],\n    [inf, inf, 7, 0, 9, 14, inf, inf, inf],\n    [inf, inf, inf, 9, 0, 10, inf, inf, inf],\n    [inf, inf, 4, 14, 10, 0, 2, inf, inf],\n    [inf, inf, inf, inf, inf, 2, 0, 1, 6],\n    [8, 11, inf, inf, inf, inf, 1, 0, 7],\n    [inf, inf, 2, inf, inf, inf, 6, 7, 0]\n]\n\nprint(dijkstra(graph,0,9))\n\nResult：[0, 4, 12, 19, 21, 11, 9, 8, 14]\n\n","categories":["CodeWorld"],"tags":["Algorithm"]},{"title":"Floyd最短路径算法的python函数实现","url":"/2024/03/19/Floyd%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E7%9A%84python%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/","content":" \n\n示例图：inf=float('inf')\ngraph = [\n    [0, 4, inf, inf, inf, inf, inf, 8, inf],\n    [4, 0, 8, inf, inf, inf, inf, 11, inf],\n    [inf, 8, 0, 7, inf, 4, inf, inf, 2],\n    [inf, inf, 7, 0, 9, 14, inf, inf, inf],\n    [inf, inf, inf, 9, 0, 10, inf, inf, inf],\n    [inf, inf, 4, 14, 10, 0, 2, inf, inf],\n    [inf, inf, inf, inf, inf, 2, 0, 1, 6],\n    [8, 11, inf, inf, inf, inf, 1, 0, 7],\n    [inf, inf, 2, inf, inf, inf, 6, 7, 0]\n]\n\nFloyd最短路径算法的python函数实现：def floyd(graph):\n    FMAX&#x3D;999\n    n&#x3D;len(graph)\n    d&#x3D;[[graph[i][j] if graph[i][j]!&#x3D;0 else FMAX for i in range(n)]for j in range(n)]\n    for k in range(n):#中转节点\n        for i in range(n):#起始节点\n            for j in range(n):#结束节点\n                #起始节点-&gt;结束节点 和 起始节点-&gt;中转节点-&gt;结束节点 之间的最小值\n                d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j])\n    return d\n\nprint(floyd(graph))\n\nResult：[[8, 4, 12, 19, 21, 11, 9, 8, 14], \n [4, 8, 8, 15, 22, 12, 12, 11, 10], \n [12, 8, 4, 7, 14, 4, 6, 7, 2], \n [19, 15, 7, 14, 9, 11, 13, 14, 9], \n [21, 22, 14, 9, 18, 10, 12, 13, 16], \n [11, 12, 4, 11, 10, 4, 2, 3, 6], \n [9, 12, 6, 13, 12, 2, 2, 1, 6], \n [8, 11, 7, 14, 13, 3, 1, 2, 7], \n [14, 10, 2, 9, 16, 6, 6, 7, 4]]\n\n\n","categories":["CodeWorld"],"tags":["Algorithm"]},{"title":"VBS实现QQ自动发送早自习请假","url":"/2024/03/02/VBS%E5%AE%9E%E7%8E%B0QQ%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E6%97%A9%E8%87%AA%E4%B9%A0%E8%AF%B7%E5%81%87/","content":"VBS实现QQ自动发送早自习请假是否你还在为早自习请假而犯愁，需要在凌晨6点前完成请假手续，导致无法好好休息，甚至需要提前起床？现在，有了这个教程，你可以轻松实现QQ自动发送早自习请假，不再为时间问题而纠结！跟随我们的步骤，一步步操作，让你轻松请假，享受更多休息时间！\n一．配置\n首先下载VBS文件：http://47.104.64.75:82/abcd.vbs\n请尝试运行，若出现报错，请下载：http://47.104.64.75:82/wscript.exe，并将文件放在“C:\\Windows\\System32”文件夹下\n然后右键abcd.vbs文件，在记事本中编辑\n将“你要说的话”替换为你的请假信息，注意！不要换行！\n然后保存关闭\n打开windows主页面，搜索“任务计划程序”并打开按照图片进行操作：\n\n选择一个时间，注意！时间一定为过去的日期\n找到你的abcd.vbs文件的位置\n\n保存退出即可\n打开文件管理器，上方输入“控制面板\\系统和安全\\电源选项”，如图：\n\n回车后找到：\n二．使用睡觉前打开QQ的纪检请假专用聊天框，一定要保持在前台（即光标在输入区内），保持电脑打开，电量充足，然后就可以上床睡觉啦~\n三．免责声明本软件&#x2F;脚本“VBS实现QQ自动发送早自习请假”仅供学习交流使用，严禁用于任何非法或侵犯他人权益的目的。使用本软件&#x2F;脚本，您应自行承担所有风险，包括但不限于账号安全、隐私泄露、法律纠纷等。\n重要提示：\n\n非法使用：本软件&#x2F;脚本的任何非法使用，包括但不限于未经授权的自动化操作、恶意攻击他人系统、发送垃圾信息等，均属于违法行为，使用者将承担全部法律责任。\n账号安全：使用本软件&#x2F;脚本可能导致您的QQ账号面临被封禁或其他安全风险。请确保您完全理解并接受这些风险。\n隐私泄露：在使用本软件&#x2F;脚本时，您的个人信息（如QQ号、密码等）可能会暴露。请确保您在一个安全的环境中使用，并采取适当的保护措施。\n第三方责任：本软件&#x2F;脚本的使用可能涉及第三方服务或平台。对于因使用本软件&#x2F;脚本而导致的与第三方之间的任何纠纷或法律责任，本软件&#x2F;脚本的开发者不承担任何责任。\n\n开发者责任限制：\n\n本软件&#x2F;脚本的开发者对于因使用本软件&#x2F;脚本而导致的任何直接或间接损失、损害、法律责任或纠纷，不承担任何责任。\n开发者有权在不通知用户的情况下，对本软件&#x2F;脚本进行更新、修改或终止服务。\n\n用户义务：\n\n用户应自行备份重要数据，并确保在使用本软件&#x2F;脚本前已充分了解其功能和风险。\n用户应遵守所有适用的法律法规，以及使用本软件&#x2F;脚本所涉及的第三方平台或服务的规定。\n\n最终解释权：\n本免责声明的最终解释权归本软件&#x2F;脚本的开发者所有。如有任何疑问或需要进一步的解释，请通过合法途径联系开发者。\n","categories":["CodeWorld"],"tags":["曲园"]},{"title":"python实现2024春晚魔术","url":"/2024/03/02/python%E5%AE%9E%E7%8E%B02024%E6%98%A5%E6%99%9A%E9%AD%94%E6%9C%AF/","content":"#央视龙年春晚 魔术《守岁共此时》，邀请全国观众一起见证奇迹发生\npython实现2024春晚魔术import random\ncards=[1,2,3,4]\nrandom.shuffle(cards)\nprint(\"打乱后的卡牌：\",cards)\ncards=cards+cards\nprint(\"撕开的卡牌：\",cards)\nname=int(input(\"姓名有几个字？\"))\nfor i in range(name):\n    cards.append(cards.pop(0))\nprint(\"当前卡牌；\",cards)\ntop_three_cards=cards[:3]\nelse_cards=cards[3:]\ninsert_index=random.randint(1,5)\ncards=else_cards[:insert_index]+top_three_cards+else_cards[insert_index:]\nprint(\"当前卡牌；\",cards)\ntop_card=cards.pop(0)\nregion=input(\"你是南方人还是北方人？(“南”、“北”？)\")\nif region == \"南\":\n    insert_count = 1\nelif region == \"北\":\n    insert_count = 2\nelse:\n    insert_count = 3\ntop=cards[:insert_count]\nelse_cards=cards[insert_count:]\ninsert_index=random.randint(0,len(else_cards)-1)\ncards=else_cards[:insert_index]+top+else_cards[insert_index:]\nprint(\"当前卡牌；\",cards)\ngender=input(\"“男”/“女”？\")\nif gender == \"男\":\n    take_count = 1\nelif gender == \"女\":\n    take_count = 2\nfor i in range(take_count):\n    cards.pop(0)\nfor i in range(len(\"见证奇迹的时刻\")):\n    cards.append(cards.pop(0))\nwhile True:\n    cards.append(cards.pop(0))\n    cards.pop(0)\n    if len(cards)==1:\n        break\n    else:\n        print(cards)\nprint(\"你刚才藏起来的牌是：\",top_card)\nprint(\"你手里剩下的牌是：\",cards[0])\nprint(\"按任意键结束并关闭页面\")\ninput() # 等待用户输入\n","categories":["CodeWorld"],"tags":["有趣"]},{"title":"一元三次方程求解","url":"/2024/03/17/%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/","content":"有形如：ax3+bx2+cx+d&#x3D;0 这样的一个一元三次方程。给出该方程中各项的系数(a，b，c，d 均为实数)，并约定该方程存在三个不同实根(根的范围在-100至100之间)，且根与根之差的绝对值&gt;&#x3D;1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后2位。\nMyCodea,b,c,d=map(int,input().split())\ndef y(x):\n    return a*x**3+b*x**2+c*x+d\nfor i in range(-100,100):\n    left=i\n    right=i+1\n    y1=y(left)\n    y2=y(right)\n    if y1==0:\n        print(\"&#123;:.2f&#125;\".format(left), end=' ')\n    if y1*y2&lt;0:\n        while right-left>=0.001:\n            mid=(left+right)/2\n            if y(mid)*y(right)&lt;=0:\n                left=mid\n            else:\n                right=mid\n        print(\"&#123;:.2f&#125;\".format(right), end=' ')\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"个位数统计","url":"/2024/03/15/%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/","content":"L1-003 个位数统计\nlink\n给定一个 k 位整数 N&#x3D;d**k−110k−1+⋯+d1101+d0 (0≤d**i≤9, i&#x3D;0,⋯,k−1, d**k−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N&#x3D;100311，则有 2 个 0，3 个 1，和 1 个 3。\n输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。\n输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。\n输入样例：100311\n\n输出样例：0:2\n1:3\n3:1\n\nMycodeN=input()\ndir=&#123;&#125;\nfor i in N:\n    if i in dir:\n        dir[i]+=1\n    else:\n        dir[i]=1\ndir=sorted(dir.items(),key=lambda  x:x[0])\nfor i in dir:\n    print(\"%d:%d\" % (int(i[0]),int(i[1])))\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"分糖果","url":"/2024/03/21/%E5%88%86%E7%B3%96%E6%9E%9C/","content":"问题描述11.分糖果 - 蓝桥云课 (lanqiao.cn)\n最近暑期特训算法班的同学们表现出色，他们的老师肖恩决定给他们分发糖果。肖恩购买了 个不同种类的糖果，用小写的阿拉字母表示。每个糖果必须分发给一个同学，并且每个同学至少要分到一个糖果。同学们的开心程度定义为他们所分到的糖果组成的字符串 s的字典序。肖恩希望同学们的开心程度相差尽量小，因此他要找到一种方案，使得所有糖果组成的字符串中字典序最大的字符串尽可能小。请输出能够实现字典序最小可能的 max(s1, 2,s3,…,st)。\n输入描述第一行输入两个整数n和2，分别表示有n个糖果个同学第二行输入一个长度为n的字符串S，S表示第i个糖果的种类\n输出描述输出一个字符串，为所有糖果组成的字符串中字典序最大的字符串最小的可能值。\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"压缩字符串","url":"/2024/03/17/%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题目描述实现一个算法来压缩一个字符串。压缩的要求如下1.需要判断压缩能不能节省空间，仅在压缩后字符串比原字符串长度更短时进行压缩。2.压缩的格式是将连续相同字符替换为字符 +数字形式，例如”AAABCCDDDD”变为”A3BC2D4”。输入描述输入一行字符串，长度不超过 500.输出描述输出一行。若输入的字符串可压缩，则输出压缩后的字符串，否则输出 NO。\nMyCodedef yasuo(txt):\n    a=1\n    txt+=\"@\"\n    result=\"\"\n    for i in range(len(txt)-1):\n        if txt[i]==txt[i+1]:\n            a+=1\n        else:\n            if a!=1:\n                result += txt[i] + str(a)\n            else:\n                result+=txt[i]\n            a=1\n    return result\na=input()\nif len(yasuo(a))&lt;len(a):\n    print(yasuo(a))\nelse:\n    print(\"NO\")\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"填充","url":"/2024/03/23/%E5%A1%AB%E5%85%85/","content":"问题描述有一个长度为n的01串，其中有一些位置标记为?，这些位置上可以任意填充0或者1，请问如何填充这些位置使得这个01串中出现互不重叠的00和11子串最多，输出子串个数。\n输入格式输入一行包含一个字符串。\n输出格式输出一行包含一个整数表示答案\n样例输入1110?0\n样例输出2\n样例说明如果在问号处填0，则最多出现一个 00 和一个11:111000\n解法\n暴力：假设一共有m个问号，那么每个问号要么写0要么写1，则一共有2……m种写法\n贪心：你找到了一个最优策略，利用这个策略可以直接找出最优解\n假设字符串固定了，那么你该怎样让字符组成字串，使得合法字串最多？\n对于中间的字符而言，优先和前面的匹配\n \n\nstr=input()\nans=0\nli=[False for i in range(len(str))]#记录i位置是否匹配过\nfor i in range(len(str)):\n    if str[i]!=\"?\":\n        if li[i]==False:\n            if (i-1)>=0 and str[i-1]==str[i] and (li[i-1]==False):\n                li[i-1]=True\n                li[i]=True\n                ans+=1\n            elif (i+1)&lt;len(str) and str[i+1]==str[i] and (li[i+1]==False):\n                li[i]=True\n                li[i+1]=True\n                ans+=1\n    else:\n        if (li[i]):\n            continue\n        if (i-1)>=0 and (li[i-1]==False):\n            li[i-1]=True\n            li[i]=True\n            ans+=1\n        elif (i+1)&lt;len(str) and (li[i+1]==False):\n            li[i]=True\n            li[i+1]=True\n            ans+=1\nprint(ans)\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"天干地支","url":"/2024/03/25/%E5%A4%A9%E5%B9%B2%E5%9C%B0%E6%94%AF/","content":"\nMyCodeTianGan=[\"jia\",\"yi\",\"bing\",\"ding\",\"wu\",\"ji\",\"geng\",\"xin\",\"ren\",\"gui\"]\n\nDiZhi=[\"zi\",\"chou\",\"yin\",\"mao\",\"chen\",\"si\",\"wu\",\"wei\",\"shen\",\"you\",\"xu\",\"hai\"]\n\nyear=int(input())-4\n\nt=year%10\n\nd=year%12\n\nprint(TianGan[t]+DiZhi[d])\n\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"平均","url":"/2024/03/23/%E5%B9%B3%E5%9D%87/","content":"问题描述有一个长度为n的数组(n是10的倍数)，每个数ai都是区间0-9中的整数。小明发现数组里每种数出现的次数不太平均，而更改第个数的代价为 b，他想更改若干个数的值使得这10种数出现的次数相等(都等于)，请问代价和最少为多少。\n输入格式输入的第一行包含一个正整数n。接下来n行，第i行包含两个整数 ai,bi，用一个空格分隔\n输出格式输出一行包含一个正整数表示答案\nCoden = int(input())\n\n#每个数ai都是区间[0，9]的整数，所以创建列表，里面存放0-10中每个数字是第几个数\nnumbers = [[] for i in range(10)]\n\n#长度为n的数组输入\nfor i in range(n):\n    a, b = map(int,input().split())\n    numbers[a].append(b)                #例如数字1，是第1,2,3个\n\nans = 0                         #代价为0\nk = n//10                       #长度为n，有n//10个10\nfor i in range(10):\n#对numbers[i]中的数进行从小到大排序，因为不用替换的数为最大的数\n#例如：1，是第1，2，3，不用替换的数为3，即最大的数3\n    ls = sorted(numbers[i])     \n#代价和为-k前面的数的和;因为有k个代价最大的数，为保证代价尽可能小，这些k个代价就不用，就加到倒数第k个之前的代价\n    ans += sum(ls[:-k])\nprint(ans)\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"念数字","url":"/2024/03/16/%E5%BF%B5%E6%95%B0%E5%AD%97/","content":"L1-007 念数字\nL1-007 念数字 - 团体程序设计天梯赛-练习集 (pintia.cn)\n输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出fu字。十个数字对应的拼音如下：\n0: ling\n1: yi\n2: er\n3: san\n4: si\n5: wu\n6: liu\n7: qi\n8: ba\n9: jiu\n\n输入格式：输入在一行中给出一个整数，如：1234。\n提示：整数包括负数、零和正数。\n输出格式：在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如yi er san si。\n输入样例：-600\n\n输出样例：fu liu ling ling\n\nMyCodeli=[(\"0\",\"ling\"),(\"1\",\"yi\"),(\"2\",\"er\"),(\"3\",\"san\"),(\"4\",\"si\"),(\"5\",\"wu\"),(\"6\",\"liu\"),(\"7\",\"qi\"),(\"8\",\"ba\"),(\"9\",\"jiu\"),]\nnum=input()\nresult=[]\nif num[0]==\"-\":\n    result.append(\"fu\")\n    for i in num[1:]:\n        if (i==li[int(i)][0]):\n            result.append(li[int(i)][1])\nelse:\n    for i in num:\n        if (i==li[int(i)][0]):\n            result.append(li[int(i)][1])\nprint(\" \".join(map(str,result)))\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"打印沙漏","url":"/2024/03/15/%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/","content":"L1-002 打印沙漏\nL1-002 打印沙漏 - 团体程序设计天梯赛-练习集 (pintia.cn)\n本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印\n*****\n ***\n  *\n ***\n*****\n\n所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。\n给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。\n输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。\n输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。\n输入样例:19 *\n\n输出样例:*****\n ***\n  *\n ***\n*****\n2\n\nMyCoden,symbol=input().split()\nn=int(n)\nif n&lt;7:\n    print(symbol)\n    print(n-1)\nelse:\n    li = []\n    space_li = []\n    space_num = 0\n    for i in range(1, n, 2):\n        li.append(i)\n        if (sum(li) + sum(li[1:])) >= n:\n            if (sum(li) + sum(li[1:])) != n:\n                li.pop()\n            li = (li[1:])[::-1] + li\n            a = n - sum(li)\n            break\n    for i in li:\n        if i == 1:\n            space_li.append(space_num)\n            space_li = space_li + (space_li[0:li.index(i)])[::-1]\n            break\n        space_li.append(space_num)\n        space_num += 1\n    for i in range(len(space_li)):\n        print(space_li[i] * \" \", end=\"\")\n        print(li[i] * symbol)\n    print(a)\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"扫雷","url":"/2024/03/24/%E6%89%AB%E9%9B%B7/","content":"题目描述在一个n行m列的方格图上有一些位置有地雷，另外一些位置为空。请为每个空位置标一个整数，表示周围八个相邻的方格中有多少个地雷。\n输入描述输入的第一行包含两个整数n,m。第2行到第n+1行每行包含m个整数，相整数之间用一个空格分隔。如果对应的整数为0，表示这一格没有地雷。如果对应的整数为1，表示这一格有地雷\n输出描述输出n行，每行m个整数，相邻整数之间用空格分隔对于没有地雷的方格，输出这格周围的地雷数量。对于有地雷的方格，输出9。\ni-1,j-1  i-1,j  i-1,j+1\n\ni,j-1    i,j  i,j+1\n\ni+1,j-1  i+1,j  i+1,j+1\n\nMyCoden,m=map(int,input().split())\nmaps=[[3 for i in range(m+2)]]\nres=[[0 for i in range(m)] for j in range(n)]\nfor i in range(n):\n    a=[3]+list(map(int, input().split()))+[3]\n    maps.append(a)\nmaps.append([3 for i in range(m+2)])\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        if maps[i][j]==1:\n            res[i-1][j-1]=9\n        else:\n            temp=0\n            if maps[i-1][j-1]==1:\n                temp+=1\n            if maps[i-1][j]==1:\n                temp+=1\n            if maps[i-1][j+1]==1:\n                temp+=1\n            if maps[i][j-1]==1:\n                temp+=1\n            if maps[i][j+1]==1:\n                temp+=1\n            if maps[i+1][j-1]==1:\n                temp+=1\n            if maps[i+1][j]==1:\n                temp+=1\n            if maps[i+1][j+1]==1:\n                temp+=1\n            res[i-1][j-1]=temp\nfor i in res:\n    print(\" \".join(map(str,i)))\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"指定时间刷新教务平台","url":"/2024/03/02/%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%88%B7%E6%96%B0%E6%95%99%E5%8A%A1%E5%B9%B3%E5%8F%B0/","content":"指定时间刷新教务平台人类有反应时间，但是机器没有!\n免责声明本程序“指定时间刷新教务平台”在使用本程序进行评价时，请遵循以下免责条款：\n1.非官方工具：本工具仅为学习交流使用而设计，并非由学校或任何官方机构开发和授权。使用本工具并不代表您获得了任何官方授权或支持。2.不得用于抢课：明确禁止用户将本工具用于抢课、选课或其他违反学校教务管理规定的行为。任何违反规定的行为，均可能导致您受到学校或相关机构的纪律处分。3.风险自负：使用本工具存在一定的风险，包括但不限于数据丢失、系统崩溃、网络延迟等。您应自行承担使用本工具所产生的所有风险和后果。4.不承担任何责任：对于因使用本工具而引发的任何直接或间接损失、损害或纠纷，包括但不限于课程选择失败、数据丢失、系统问题等，我们概不负责，也不承担任何法律责任。5.遵守法律法规：您应确保在使用本工具时遵守所有适用的法律法规，不得将本工具用于任何非法或侵犯他人权益的目的。6.学习交流用途：本工具仅供学习交流使用，不得用于任何商业或其他非学习交流的目的。鉴于以上免责声明，若用户在使用本程序过程中违反了以上任何一项规定，应自行承担相应的法律责任。在使用本程序之前，用户应仔细阅读并充分理解本免责声明的所有内容，一旦使用本程序，即表示已接受并同意本免责声明的所有条款。\n// ==UserScript==\n// @name         New Userscript\n// @namespace    http://tampermonkey.net/\n// @version      2024-02-22\n// @description  try to take over the world!\n// @author       Ianwusb\n// @match        http://zhjw.qfnu.edu.cn/jsxsd/framework/xsMain.jsp\n// @icon         https://www.google.com/s2/favicons?sz=64&amp;domain=qfnu.edu.cn\n// @grant        none\n// ==/UserScript==\n\nfunction checkAndRefresh() &#123;\n    // 指定9:00:00\n    const specifiedHours = 9;\n    const specifiedMinutes = 0;\n    const specifiedSeconds = 0;\n\n    const now = new Date();\n    const currentHours = now.getHours();\n    const currentMinutes = now.getMinutes();\n    const currentSeconds = now.getSeconds();\n\n    // 检查当前时间是否达到指定的9:00:00\n    if (currentHours === specifiedHours &amp;&amp; currentMinutes === specifiedMinutes &amp;&amp; currentSeconds === specifiedSeconds) &#123;\n        location.reload(); // 如果时间匹配，则刷新页面\n    &#125;\n\n    // 每秒检查一次\n    setTimeout(checkAndRefresh, 1000);\n&#125;\n\n// 开始检查\ncheckAndRefresh();\n\n零基础使用教程1.打开Tampermonkey官网\n2.点击“去商店”，页面跳转至对应浏览器扩展商店的安装页面，我们直接获取安装就好了\n3.打开油猴插件，选择“添加新脚本”，将上面的代码复制粘贴上去，在“文件”点击“保存”即可\n4.登录教管页面后等待到达指定时间即可\n","categories":["CodeWorld"],"tags":["曲园"]},{"title":"曲园半自动教评打分","url":"/2024/03/02/%E6%9B%B2%E5%9B%AD%E5%8D%8A%E8%87%AA%E5%8A%A8%E6%95%99%E8%AF%84%E6%89%93%E5%88%86/","content":"曲园半自动教评打分给老师打分太麻烦了，问了师哥也没用全自动打分的油猴脚本，于是乎自己写了一个，目前只能算半自动\n免责声明  本程序“曲园全自动教评打分”仅为辅助学生进行教师评价之用，所有评价数据及结果仅供参考。在使用本程序进行评价时，请遵循以下免责条款：\n1.公正性：用户应公正、客观地使用本程序进行评价，不得因个人偏见、情绪或其他非客观因素影响评价结果。\n2.准确性：用户应准确理解评价标准，确保评价内容真实、准确。若因用户输入错误或不实信息导致的评价结果偏差，本程序不承担任何责任。\n3.具体性：用户在评价时应提供具体、详细的例子或事例，以便于其他用户更好地理解评价内容。\n4.建设性：用户应对评价结果提供具体的、有益的建议或意见，以帮助改进教学质量。\n5.尊重性：用户应对教师的付出和努力表示尊重，避免发表无谓的负面评价或攻击性言论。\n  鉴于以上免责声明，若用户在使用本程序过程中违反了以上任何一项规定，应自行承担相应的法律责任。本程序不对评价结果的真实性、准确性、公正性等承担任何形式的保证或担保。在使用本程序之前，用户应仔细阅读并充分理解本免责声明的所有内容，一旦使用本程序，即表示已接受并同意本免责声明的所有条款。\n// ==UserScript==\n// @name         曲园全自动教评打分\n// @namespace    http://example.com/\n// @version      1.0\n// @description  曲园全自动教评打分(声明见：https://www.luogu.com.cn/blog/ianwusb/quyuansoringauto)\n// @author       ianwusb from(https://www.luogu.com.cn/blog/ianwusb/)\n// @match        http://202.194.188.38/*\n// @grant        none\n// ==/UserScript==\n\n(function() &#123;\n    'use strict';\n\n    // 指定要点击的元素的ID数组\n    const targetElementIds = ['pj0601id_2_2', 'pj0601id_3_2', 'pj0601id_4_2','pj0601id_5_2','pj0601id_6_2','pj0601id_7_2','pj0601id_8_2','pj0601id_9_2','pj0601id_10_2','pj0601id_11_1']; // 修改为你的目标元素ID数组\n\n    // 获取目标元素列表\n    const targetElements = document.querySelectorAll('#' + targetElementIds.join(', #'));\n\n    // 检查元素是否存在\n    if (targetElements.length > 0) &#123;\n        // 直接模拟点击所有目标元素的操作\n        targetElements.forEach(function(element) &#123;\n            simulateClick(element); // 对每个目标元素执行模拟点击操作\n        &#125;);\n    &#125; else &#123;\n        console.error('Target elements not found');\n    &#125;\n\n    // 模拟鼠标点击元素的函数\n    function simulateClick(element) &#123;\n        const clickEvent = document.createEvent('MouseEvents');\n        clickEvent.initEvent('click', true, true); // 创建并初始化一个click事件对象\n        element.dispatchEvent(clickEvent); // 在目标元素上触发click事件，模拟鼠标点击操作\n    &#125;\n&#125;)();\n零基础使用教程1.打开Tampermonkey官网\n2.点击“去商店”，页面跳转至对应浏览器扩展商店的安装页面，我们直接获取安装就好了\n3.打开油猴插件，选择“添加新脚本”，将上面的代码复制粘贴上去，在“文件”点击“保存”即可\n4.返回教管教评页面进入打分界面，点击提交即可\n有问题可在评论区评论","categories":["CodeWorld"],"tags":["曲园"]},{"title":"最大距离","url":"/2024/03/26/%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/","content":"\nn=int(input())\n\nli=list(map(int,input().split()))\n\nmax=-1\n\ndef distance(i, j):\n\n  return abs(i-j)+abs(li[i]-li[j])\n\nfor i in range(len(li)):\n\n  for j in range(1,len(li)):\n\n     if distance(i,j)>max:\n\n       max=distance(i,j)\n\nprint(max)\n\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"最长递增","url":"/2024/03/26/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E/","content":"\nn=int(input())\nli=list(map(int,input().split()))\nlen_list=[]\nfor i in range(len(li)):\n  for j in range(1,len(li)):\n     temp=li[i:j]\n     if len(temp)!=0:\n       sort_temp = sorted(temp)\n       if sort_temp == temp:\n         len_list.append(len(temp))\nprint(max(len_list))\n\n\nn = int(input())\n\nls = [*map(int,input().split())]\n\ncountmax = 1\ncount = 1\n\nfor i in range(len(ls)-1):\n  if ls[i] &lt; ls[i+1]:\n    count += 1\n  else:\n    count = 1\n  countmax = max(countmax,count)\n\nprint(countmax)\n\n\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"灌水","url":"/2024/03/12/%E7%81%8C%E6%B0%B4/","content":"问题描述小蓝有一个01 矩阵。他打算将第一行第一列的0变为 2。变化过程有传染性，每次 2 的上下左右四个相邻的位置中的0都会变成2。直到最后每个2的周围都是1或2结束请问，最终矩阵中有多少个 2?以下是小蓝的矩阵，共30行40 列\n0000100010000001101010101001001100000011 0101111001111101110111100000101010011111 1000010000011101010110000000001011010100 0110101010110000000101100100000101001001 0000011010100000111111001101100010101001 0110000110000000110100000000010010100011 0100110010000110000000100010000101110000 0010011010100110001111001101100110100010 1111000111101000001110010001001011101101 0011110100011000000001101001101110100001 0000000101011000010011111001010011011100 0000100000011001000100101000111011101100 0010110000001000001010100011000010100011 0110110000100011011010011010001101011011 0000100100000001010000101100000000000010 0011001000001000000010011001100101000110 1110101000011000000100011001001100111010 0000100100111000001101001000001010010001 0100010010000110100001100000110111110101 1000001001100010011001111101011001110001 0000000010100101000000111100110010101101 0010110101001100000100000010000010110011 0000011101001001000111011000100111010100 0010001100100000011000101011000000010101 1001111010010110011010101110000000101110 0110011101000010100001000101001001100010 1101000000010010011001000100110010000101 1001100010100010000100000101111111111100 1001011010101100001000000011000110110000 0011000100011000010111101000101110110001\n答案提交这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\nMycodepython\ndef print_li(li):\n    a &#x3D; str(li)\n    for i in range(len(a)):\n        try:\n            if a[i - 2] &#x3D;&#x3D; &quot;]&quot; and a[i - 1] &#x3D;&#x3D; &quot;,&quot; and a[i] &#x3D;&#x3D; &quot; &quot;:\n                print(&quot;\\r&quot;)\n            else:\n                print(a[i], end&#x3D;&quot;&quot;)\n        except IndexError:\n            break\n    print(&quot;\\n&quot;)\ndef input_li():\n    result&#x3D;[]\n    for i in range(30):#5行\n        a&#x3D;input()\n        li&#x3D;[]\n        for j in a:\n            li.append(int(j))\n        result.append(li)\n    return result\ndef DFS(li,x1,y1):\n    s_x&#x3D;x1\n    s_y&#x3D;y1\n    temp_y&#x3D;y1\n    try:\n        while li[s_x+1][s_y]&#x3D;&#x3D;0:\n            li[s_x+1][s_y]&#x3D;2\n            try:\n                while li[s_x+1][s_y+1]&#x3D;&#x3D;0:\n                    li[s_x+1][s_y + 1]&#x3D;2\n                    s_y+&#x3D;1\n            except IndexError:\n                break\n            s_y&#x3D;temp_y\n            s_x+&#x3D;1\n    except IndexError:\n        return\ndef output_li(li):\n    result&#x3D;0\n    for i in str(li):\n        if i&#x3D;&#x3D;&quot;2&quot;:\n            result+&#x3D;1\n    return result\nli&#x3D;input_li()\nprint_li(li)\nfor j in range(40):#5列\n    for i in range(30):#5行\n        DFS(li,j,i)\n        if li[i][j]&#x3D;&#x3D;0:\n            li[i][j]&#x3D;2\nprint_li(li)\nfor j in range(40):#5列\n    for i in range(30):#5行\n        try:\n            if li[i-1][j]&#x3D;&#x3D;1 and li[i][j-1]&#x3D;&#x3D;1 and li[i][j+1]&#x3D;&#x3D;1:\n                li[i][j]&#x3D;8\n        except IndexError:\n            break\nprint_li(li)\n# if j &#x3D;&#x3D; 0:\n#     if li[i - 1][j] &#x3D;&#x3D; 1 or li[i - 1][j] &#x3D;&#x3D; 8:\n#         li[i][j] &#x3D; 8\n# elif j &#x3D;&#x3D; 39:  # 第5列\n#     if li[i + 1][j] &#x3D;&#x3D; 1 or li[i + 1][j] &#x3D;&#x3D; 8:\n#         li[i][j] &#x3D; 8\n# el\n\nMyOutput[[2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 8, 1, 8, 1, 8, 1, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1],[2, 1, 2, 1, 8, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 8, 1, 8, 1, 8, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 8, 1, 2, 2, 1, 1, 1, 8, 1],[1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 8, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 8, 1, 2, 2],[8, 1, 1, 2, 1, 8, 1, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 8, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 8, 1, 2, 2, 1, 2, 2, 1],[2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 8, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2, 1, 8, 1, 2, 1, 2, 2, 1],[2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 8, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1],[2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 8, 1, 8, 1, 2, 2, 2, 2],[2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 8, 1, 1, 2, 2, 1, 1, 8, 1, 2, 2, 2, 1, 2],[1, 1, 8, 1, 2, 2, 2, 1, 8, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 8, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 8, 1, 1, 1, 2, 1, 1, 8, 1],[2, 2, 1, 8, 1, 1, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 8, 1, 2, 2, 1, 1, 2, 1, 1, 1, 8, 1, 2, 2, 2, 2, 1],[2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 8, 1, 1, 1, 2, 2, 1, 8, 1, 2, 2, 1, 1, 8, 1, 1, 1, 2, 2],[2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 8, 1, 2, 2, 2, 1, 8, 1, 2, 1, 8, 1, 8, 1, 1, 2, 2],[2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 8, 1, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1],[2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 1, 8, 1, 8, 1, 1, 2, 1, 1],[2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 8, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2],[2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 2],[1, 1, 1, 8, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 8, 1, 2],[2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 8, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 8, 1, 2, 2, 1, 2, 2, 2, 1],[2, 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 1, 8, 1, 8, 1, 1, 1, 2, 1, 2, 1],[1, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 8, 1, 1, 1, 2, 1, 8, 1, 1, 2, 2, 1, 8, 1, 2, 2, 2, 1],[2, 2, 2, 2, 2, 2, 2, 2, 1, 8, 1, 2, 2, 1, 8, 1, 2, 2, 2, 2, 2, 2, 1, 8, 1, 1, 2, 2, 1, 1, 2, 2, 1, 8, 1, 8, 1, 1, 2, 1],[2, 2, 1, 2, 1, 1, 2, 1, 8, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1],[2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 1, 1, 1, 2, 1, 1, 2, 2, 2, 1, 2, 2, 1, 8, 1, 8, 1, 2, 1, 2, 2],[2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 8, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2, 1],[1, 2, 2, 1, 1, 1, 1, 8, 1, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 8, 1, 8, 1, 2],[2, 1, 1, 2, 2, 1, 8, 1, 8, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 8, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2, 1, 2],[1, 1, 8, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 8, 1],[1, 2, 2, 1, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 8, 1, 1, 1, 8, 1, 1, 1, 1, 1, 2, 2],[1, 2, 2, 1, 8, 1, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 8, 1, 1, 2, 2, 2, 2],[2, 2, 1, 1, 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 8, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 1, 8, 1, 2, 1, 1, 2, 2, 2, 1]]\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"灌溉","url":"/2024/03/26/%E7%81%8C%E6%BA%89/","content":"题目描述小蓝负责花园的灌溉工作花园可以看成一个n行m列的方格图形。中间有一部分位置上安装有出水管小蓝可以控制一个按钮同时打开所有的出水管，打开时，有出水管的位置可以被认为已经灌溉好每经过一分钟，水就会向四面扩展一个方格，被扩展到的方格可以被认为已经灌溉好。即如果前一分钟某一个方格被灌溉好，则下一分钟它上下左右的四个方格也被灌溉好给定花园水管的位置，请问k分钟后，有多少个方格被灌溉好?\n输入描述输入的第一行包含两个整数n,m。第二行包含一个整数t，表示出水管的数量接下来t行描述出水管的位置，其中第行包含两个数rc表示第r行第c列有一个排水管。接下来一行包含一个整数 k。其中，1&lt;&#x3D;n,m&lt;&#x3D;100,1&lt;&#x3D;t&lt;&#x3D; 10,1&lt;&#x3D; k&lt;&#x3D;100.\n输出描述输出一个整数，表示答案\nn,m = map(int,input().split())\nt = int(input())\na = [[0 for i in range(m)] for j in range(n)]  #初始的方格\nb = [[0 for i in range(m)] for j in range(n)]  #灌溉后的方格\nfor i in range(t):\n    r,c = map(int,input().split())\n    a[r-1][c-1] = 1   #初始化出水口\nk = int(input())\n#遍历\nfor k in range(k,0,-1):    #一分钟灌溉一次\n    for i in range(n):\n        for j in range(m):\n            if a[i][j]==1:\n                b[i][j]=1  #中心值标记\n                if i-1>=0:  #合格范围编辑四个方向的水管\n                    b[i-1][j]=1\n                if i+1&lt;n:\n                    b[i+1][j]=1\n                if j-1>=0:\n                    b[i][j-1]=1\n                if j+1&lt;m:\n                    b[i][j+1]=1\n    a = b                   #灌溉完毕递归下一次\n#输出\ncnt = 0\nfor i in b:\n    for j in i:\n        cnt += j\nprint(cnt)\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"硬币兑换(???)","url":"/2024/03/24/%E7%A1%AC%E5%B8%81%E5%85%91%E6%8D%A2/","content":"\nresult=[0 for r in range(4047)]\nfor i in range(1,2024):\n    for j in range(i+1,2024):\n        result[i+j]+=i\nprint(max(result))\n\n\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"答疑","url":"/2024/03/06/%E7%AD%94%E7%96%91/","content":"答疑题目介绍有 n 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。一位同学答疑的过程如下：\n\n首先进入办公室，编号为 i 的同学需要 si 毫秒的时间。\n然后同学问问题老师解答，编号为 i 的同学需要 ai 毫秒的时间。\n答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。\n最后同学收拾东西离开办公室，需要 ei 毫秒的时间。一般需要 10 秒、20 秒或 30 秒，即 ei 取值为 10000，20000 或 30000。一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群里面发消息的时刻之和最小。\n\n【输入格式】输入第一行包含一个整数 n，表示同学的数量。接下来 n 行，描述每位同学的时间。其中第 i 行包含三个整数 si, ai, ei，意义如上所述。\n【输出格式】输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。\n【样例输入】310000 10000 1000020000 50000 2000030000 20000 30000\n【样例输出】280000 280000280000\n思路同学消耗的总时间越短，优先级越高总时间相等时，优先级相同，无所谓前后\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode# s1 a1 |A1| e1 s2 a2 |(A1+e1+A2)| e2 s3 a3 |(A1+e1+A2+e2+A3)|(A1+e1+A2+e2+A3+e3+A4)\nn=int(input())\nli=[]\nfor i in range(n):\n    lis=list(map(int,input().split(\" \")))\n    li.append((lis,sum(lis)))\nli.sort(key= lambda x:x[1])\nA_li=[]\nE_li=[]\nfor i in li:#i->([10000, 10000, 10000], 30000)\n    A_li.append(i[0][0]+i[0][1])\n    E_li.append(i[0][2])\ntemp=[A_li[0]]\nfor i in range(1,len(li)):\n    c=A_li[i]\n    for j in range(i):\n        c+=A_li[j]+E_li[j]\n    temp.append(c)\nprint(sum(temp))\n\n\n\n排队接水题目描述有n 个人在一个水龙头前排队接水，假如每个人接水的时间为Ti，请编程找出这 n 个人排队的一种顺序，使得 n 个人的平均等待时间最小。\n输入格式第一行为一个整数 n。\n第二行 n个整数，第 i 个整数 Ti第 i个人的接水时间 Ti。\n输出格式输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。\n样例 #1样例输入 #110 \n56 12 1 99 1000 234 33 55 99 812\n\n样例输出 #13 2 7 8 1 4 9 6 10 5\n291.90\n\nCoden=int(input())\nli1=list(map(int,input().split(\" \")))\nli=[]\nfor i in range(len(li1)):\n    li.append((li1[i],i))\nli.sort(key= lambda x:x[0])\norder=[]\nfor i in li:\n    order.append(i[1]+1)\nprint(' '.join(map(str,order)))\nwite_time=[]\nfor i in range(len(li)):\n    a=0\n    for j in range(i):\n        a+=li[j][0]\n    wite_time.append(a)\nprint(\"%.2f\" % (sum(wite_time)/n))\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"约瑟夫环","url":"/2024/03/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","content":"已知 n 个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出圈；他的下一个人又从 1 开始报数，数到 m 的那个人又出圈；依此规律重复下去，直到剩余最后一个胜利者。\nMyCodedef josephus_problem(maxnum, startnum, stepnum):\n    # 创建一个包含从startnum%maxnum到maxnum+1的列表，再加上从1到startnum%maxnum-1的列表\n    data = list(range(startnum % maxnum, maxnum + 1)) + list(range(1, startnum % maxnum))\n    num = 0  # 初始化计数器\n    while len(data) > 1:  # 当列表长度大于1时执行循环\n        num += 1  # 计数器加1\n        temp = data.pop(0)  # 弹出列表中的第一个元素\n        if num == stepnum:  # 如果计数器等于步长\n            print(temp)  # 输出当前元素\n            num = 0  # 重置计数器\n        else:\n            data.append(temp)  # 将当前元素添加到列表末尾\n    print(data[0])  # 输出列表中剩余的唯一元素\n\nn, k, m = map(int, input().split())  # 读取输入的三个整数\njosephus_problem(n, k, m)  # 调用约瑟夫问题函数\n\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"统计数字","url":"/2024/03/17/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97/","content":"\nMyCoden=int(input())\ndir=&#123;&#125;\nfor i in range(n):\n    num=int(input())\n    if num in dir:\n        dir[num]+=1\n    else:\n        dir[num]=1\ndir=sorted(dir.items(),key=lambda x:x[0])\nfor i in dir:\n    print(i[0],i[1])\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"货物摆放","url":"/2024/03/04/%E8%B4%A7%E7%89%A9%E6%91%86%E6%94%BE/","content":"1463.货物摆放题目：题目描述小蓝有一个超大的仓库，可以摆放很多货物。现在，小蓝有n箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、宽、高。\n小蓝希望所有的货物最终摆成一个大的长方体。即在长、宽、高的方向上分别堆L、W、H的货物满足n&#x3D;L×W×H。\n给定n，请问有多少种堆放货物的方案满足要求？\n例如，当n&#x3D;4时，有以下6种方案: 1×1×4、1×2×2、1×4×1、2×1×2、2×2×1、4×1×1。\n问题请问，当n&#x3D;2021041820210418（注意有16位数字）时，总共有多少种方案？\n提示建议使用计算机编程解决问题。\n答案提交这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\nMy Answer：def factor(num):\n    li = []\n    for i in range(1, int(pow(num, 0.5)) + 1):\n        if num % i == 0:\n            li.append((i,int(num / i)))\n    return li\nnum=int(input())\ntimes=0\nfor i in factor(num):\n    if i[0]!=1 :\n        #if i[0] * i[1] == num:\n        for j in factor(i[1]):\n            #print(i[0],j[0],j[1])\n            if i[0]==j[0] and j[0]==j[1] and i[0]==j[1]:\n                times+=1\n            else:\n                times+=3\n            #print(\"times:\",times)\n    else:\n        #print(i[0],i[0],i[1])\n        times += 3\n        #print(\"times:\", times)\nprint(times)\n\nOutput：20210418202104182466\n进程已结束，退出代码为 0\nQ：正确答案是2430，多的36个哪来的？","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"缩位求和(迭代,递归)","url":"/2024/03/27/%E7%BC%A9%E4%BD%8D%E6%B1%82%E5%92%8C/","content":"题目描述在电子计算机普及以前，人们经常用一个粗略的方法来验算四则运算是否正确。比如: 248 x15 &#x3D;3720把乘数和被乘数分别逐位求和，如果是多位数再逐位求和，直到是1位数，得2+4+8&#x3D;14&#x3D;&#x3D;&gt;1+4&#x3D;5;1+5&#x3D;6;5x6而结果逐位求和为3。5x6的结果逐位求和与3符合，说明正确的可能性很大!!(不能排除错误)请你写一个计算机程序，对给定的字符串逐位求和。\n输入描述输入为一个由数字组成的串，表示n(n&lt;1000)位数\n输出描述输出为一位数，表示反复逐位求和的结果\nMyCode递归算法：递归算法是一种通过将问题分解为更小的子问题来解决问题的方法。在递归算法中，函数会调用自身来解决子问题，直到达到基本情况（base case）为止。递归算法通常具有简洁的代码，但可能会导致栈溢出等问题。\n迭代算法：迭代算法是一种通过重复执行一系列操作来解决问题的方法。在迭代算法中，不需要使用递归调用，而是通过循环结构来实现。迭代算法通常具有较好的性能，但可能需要更多的代码来实现相同的功能。\n迭代写法：num = int(input())\nx = num\ndef num_sum(a):\n    a = str(a)\n    res = 0\n    for i in a:\n        res += int(i)\n    return res\nwhile len(str(x)) != 1:\n    x = num_sum(x)\nprint(x)\n这段代码实现了一个迭代算法，用于计算一个数字的各个位数之和，直到结果为一位数为止。首先，将输入的数字转换为字符串，然后遍历字符串中的每个字符，将其转换为整数并累加到结果中。最后，当结果为一位数时，输出结果。\n递归写法：def num_sum(a):\n    if len(str(a)) == 1:\n        return a\n    else:\n        a = str(a)\n        res = 0\n        for i in a:\n            res += int(i)\n        return num_sum(res)\n\nnum = int(input())\nprint(num_sum(num))\n这段代码实现了一个递归算法，用于计算一个数字的各个位数之和，直到结果为一位数为止。首先判断输入的数字是否只有一位，如果是，则直接返回该数字；否则，将输入的数字转换为字符串，遍历字符串中的每个字符（即数字的每一位），将其转换为整数并累加到结果中。然后，将累加得到的结果作为参数，再次调用递归函数进行求和操作。这样，每次递归都会将数字的各个位数相加，直到结果只剩下一位数为止。最后，输出最终的结果。\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"质因数分解","url":"/2024/03/13/%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/","content":"质因数分解题目描述已知正整数n是两个不同的质数的乘积，试求出较大的那个质数。\n输入描述输入只有一行，包含一个正整数n，6 &lt;n&lt;2^10\n输出描述输出只有一行，包含一个正整数p，即较大的那个质数\nMycode#任何一个大于1的整数都可以分解成若干个质数的连乘积\nn=int(input())\nfor i in range(2,n):\n    if n%i==0:\n        print(n//i)\n        break\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"路径","url":"/2024/03/19/%E8%B7%AF%E5%BE%84/","content":"本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可\n小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图中的最短路径。\n小蓝的图由2021个结点组成，依次编号1至2021。\n对于两个不同的结点ab，如果a和b的差的绝对值大于21，则两个结点之间没有边相连;如果a和b的差的绝对值小于等于21，则两个点之间有一条长度为a和b的最小公倍数的无向边相连。\n例如: 结点1和结点23 之间没有边相连;结点3 和结点24 之间有一条无向边，长度为24;结点15 和结点25之间有一条无向边，长度为 75。\n请计算，结点1和结点2021之间的最短路径长度是多少\n提示:建议使用计算机编程解决问题\nMyCodeDijkstra最短路径算法的python函数实现 | Ianwusb’s Blog\ndef lcm(a,b):\n    x,y=a,b\n    while y:\n        x,y=y,x%y\n    return int((a*b)/x)\ndef dijkstra(graph,starting_node,node_num):#graph[u][v]表示边e=(u,v)的权值，不存在时设为inf\n    # 起始节点starting_node,节点数量node_num\n    used = [False for _ in range(node_num)]  # 标记数组，used[v]值为False说明该顶点还没有访问过，在S中，否则在U中！\n    distance = [float('inf') for _ in range(node_num)]  # 距离数组，distance[i]表示从原点s到i的最短距离，distance[s]=0\n    #cost = [[float('inf') for _ in range(node_num)] for _ in range(node_num)]  # cost[u][v]表示边e=(u,v)的权值，不存在时设为inf\n    distance[starting_node]=0\n    while True:\n        v=-1#v在这里相当于是一个哨兵，对包含起点s做统一处理！\n        for u in range(node_num):#从未使用过的顶点中选择一个距离最小的顶点\n            if not used[u] and (v==-1 or distance[u]&lt;distance[v]):\n                v=u\n        if v==-1:#说明所有顶点都维护到S中了！\n            break\n        used[v]=True#将选定的顶点加入到S中，同时进行距离更新\n        for u in range(node_num):#更新U中各个顶点到起点s的距离.之所以更新U中顶点的距离，是因为上一步中确定了k是求出的最短路径节点\n            distance[u]=min(distance[u],distance[v]+graph[v][u])\n\n    return distance\n\n#建图....begin\ncost = [[0 for _ in range(2021)] for _ in range(2021)]\nfor i in range(2021):\n    for j in range(2021):\n        if (abs((i+1)-(j+1))&lt;=21):\n            w=lcm(i+1,j+1)\n            cost[i][j]=w\n        elif (abs((i+1)-(j+1))>21):\n            cost[i][j]=float('inf')\n        if (i==j):\n            cost[i][j] = 0\n#建图....end\nprint(dijkstra(cost,0,2021))\n","categories":["CodeWorld"],"tags":["LanQiao"]},{"title":"金币","url":"/2024/03/25/%E9%87%91%E5%B8%81/","content":"题目描述国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币;之后两天(第二天和第三天)，每天收到两枚金币;之后三天(第四、五、六天)，每天收到三枚金币;之后四天(第七、八、九、十天)，每天收到四枚金币……;这种工资发放模式会一直这样延续下去:当连续N天每天收到金币后，骑士会在之后的连续N+1天里，每天收到N+1枚金币。请计算在前K天里，骑士一共获得了多少金币。\n输入描述输入只有1行，包含一个正整数K (1104)，表示发放金币的天数。\n输出描述输出只有1行，包含一个正整数，即骑士收到的金币数\nMyCodeK=int(input())\n\nli=[0]\n\nfor i in range(1,K+1):\n\n  for j in range(i):\n\n     li.append(i)\n\nprint(sum(li[:K+1]))\n\n","categories":["CodeWorld"],"tags":["LanQiao"]}]