{"relevantArticles":[{"articleTitle":"帮派弟位","articleAbstractText":"问题描述 小明在游戏中参加了一个帮派，这一天他突然想知道自己在帮派中是什么地位，但是帮派的查询系统突然坏了，目前只能知道每个人的附属关系，请问你能帮帮他重建关系网并找出他的地位 吗? 给定一个正整数n，代表该帮派的总人数，并且小明的序号是m 给出这n个人中每个人的附属关系，确保给出的关系网为一棵树。帮派地位的定义是按照自己手下有多少帮众决定的，注意手下的手下也算是自己的手下。如果手下的帮众相同则按序号较小的在前面。你能帮助小明找到自己的帮派地位吗? 输入格式 第一行，两个正整数n(1&lt;n&lt;10^5)和m(1&lt;=m&lt;=n)代表该帮派的总人数以及小明的序号 接下来n-1行，每行两个正整数，格式如下: L r(1&lt;L,r &lt;n)，代表序号为的L人附属于序号为r的人。 输出格式 一行，包含1个正整数，输出按手下人数多少排序后小明的排名。 Mycode n,m=map(int,input().split()) li=[] person=[[] for i in range(n+1)] person_num=[] for i in range(n-1): l,r....","articleStatus":0,"articlePermalink":"/articles/2024/04/09/1712593575150.html","articleImg1URL":"https://b3logfile.com/bing/20231130.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"前缀和与差分算法","articleAbstractText":"前缀和算法(prefix sum) 前缀和是一种简单的有效的优化算法，能把计算复杂度为O(n)的区间计算优化为O(1)的端点计算 前缀和的概念 一个长度为n的数组a[1]~a[n]，前缀和sum[i]等于a[1]~a[i]的和： sum[i]=a[1]+a[2]+...+a[i] 利用递推，可以在O(n)时间内求得所有前缀和： sum[i]=sum[i-1]+a[i] 如果预计算出前缀和，就能利用它快速计算出数组中任意一个区间a[i]~a[j]的和，即： a[i]+a[i+1]+...+a[j-1]+a[j]=sum[j]-sum[j-1] 上式说明，复杂度为O(n)的区间求和计算，优化到了O(1)的前缀和计算 前缀和例题 如果建模时发现有区间求和操作，可以考虑使用前缀和优化 例一 0求和 - 蓝桥云课 (lanqiao.cn) 将给定的计算式子变换为： $$ S = (a_1 + a_2 + \\ldots + a_{n-1}) \\times a_n + (a_1 + a_2 + \\ldots + a_{n-2}) \\times a_{n-1} + (a_1 + a_2 + ldots....","articleStatus":0,"articlePermalink":"/articles/2024/04/11/1712782568038.html","articleImg1URL":"https://img-blog.csdnimg.cn/direct/c8624238adc54d5cb0d77c8a97c848ff.png?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"蓝桥输入输出","articleAbstractText":"nums = list(map(int, input().split())) #这行代码接收用户的输入，并将输入转换为整数列表。 #首先，input()函数接收用户的输入，然后 #split()方法将这个输入拆分成一个字符串列表。 #接着，map()函数应用int()函数到列表的每个元素， #将每个字符串元素转换为整数。最后，li()函数 #将映射对象转换为列表。 print(' '.join(map(str, nums))) #这行代码将整数列表转换回字符串，并以空格分隔每个元素， #然后将整个字符串打印出来。首先，map()函数应用 #str()函数到列表的每个元素，将每个整数元素转换 #为字符串。然后，join()方法使用空格字符作为分隔符， #将字符串列表连接成一个字符串。 #最后，print()函数打印这个字符串。 #最大公约数 #约数︰如果整数a能被整数b整除，那么a叫做b的倍数， #b叫做a的约数。 #给定两个整数a,b，两个数的所有公共约数中的最大值 #即为最大公约数(Greatest Common Divisor , GCD)。 #例:12与16的最大公约数是4 #.....","articleStatus":0,"articlePermalink":"/articles/2024/04/13/1712962423139.html","articleImg1URL":"https://b3logfile.com/bing/20210709.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"01串的熵","articleAbstractText":"001串的熵 - 蓝桥云课 (lanqiao.cn) # import os # import sys # import math # # # 请在此输入您的代码 # x = 23333333 # for i in range(1,x//2): # 0出现的次数,小于x/2就能保证1的次数大于0的 # j=x-i # if round((j/x)*(math.log2(j/x))j+(i/x)(math.log2(i/x))*i,4)==-11625907.5798: # print(i) # break print(11027421)","articleStatus":0,"articlePermalink":"/articles/2024/04/09/1712593490077.html","articleImg1URL":"https://b3logfile.com/bing/20191004.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"幸运数","articleAbstractText":"问题描述 小蓝认为如果一个数含有偶数个数位，并且前面一半的数位之和等于后面一半的数位之和，则这个数是他的幸运数字。例如 2314是一个幸运数字,因为它有 4个数位,并且2+3=1+4。现在请你帮他计算从1至100000000之间共有多少个不同的幸运数字。 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 Mycode #def lucky_num(x): # len_x=len(x) # if len_x%2==0:#含有偶数个数位 # a=x[:len_x//2] # a_sum=0 # for i in a: # a_sum+=int(i) # b=x[len_x//2:] # b_sum=0 # for j in b: # b_sum+=int(j) # if a_sum==b_sum: # return 1 # else: # return 0 # else: # return 0 # res=0 # for i in range(1,100000001): # res+=lucky_num....","articleStatus":0,"articlePermalink":"/articles/2024/04/09/1712593366080.html","articleImg1URL":"https://b3logfile.com/bing/20200520.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}